default_platform(:ios)

before_all do
  # Set up CI environment if running on CI
  setup_ci if FastlaneCore::Helper.ci?
  
  # iOS-specific setup - only run on iOS platform
  if FastlaneCore::Helper.ci? && lane_context[SharedValues::PLATFORM_NAME] == :ios
    begin
      xcode_select "/Applications/Xcode-15.4.app" if File.directory?("/Applications/Xcode-15.4.app")
      if system("which xcodebuild >/dev/null 2>&1")
        UI.important("Using Xcode version: #{`xcodebuild -version`.strip}")
      else
        UI.important("xcodebuild command not available - skipping version check")
      end
    rescue => e
      UI.error("Error during Xcode setup: #{e.message}")
    end
  end
  
  # Performance optimization - disable Flipper for production builds
  ENV["DISABLE_FLIPPER"] = "1" if ENV["FASTLANE_LANE"] == "beta" || ENV["FASTLANE_LANE"] == "release"
  
  # Opt out of interactive mode for CI
  ENV["FASTLANE_OPT_OUT_USAGE"] = "1"
  ENV["FASTLANE_SKIP_UI"] = "1"
end

platform :ios do
  desc "Set up code signing using App Store Connect API"
  private_lane :setup_code_signing do
    # IMPORTANT: The key_content must be properly quoted in environment variables
    # If you're getting "invalid curve name" error, ensure your key is wrapped in quotes
    # Example: key_content="-----BEGIN PRIVATE KEY-----\nABCDEF...\n-----END PRIVATE KEY-----"
    
    # Print key format for debugging (don't worry, this only shows the format, not the actual key)
    UI.message("Key format check - first 20 chars: #{ENV["ASC_KEY_CONTENT"] ? ENV["ASC_KEY_CONTENT"][0..20] : 'nil'}")
    UI.message("Key starts with proper header: #{ENV["ASC_KEY_CONTENT"] && ENV["ASC_KEY_CONTENT"].start_with?("-----BEGIN") ? 'Yes' : 'No'}")
    UI.message("Key includes newlines (\\n): #{ENV["ASC_KEY_CONTENT"] && ENV["ASC_KEY_CONTENT"].include?('\n') ? 'Yes' : 'No'}")
    
    # Try using one of these approaches to fix the "invalid curve name" error:
    
    # Option 1: Use is_key_content_base64 if your key is base64 encoded
    if ENV["ASC_KEY_CONTENT_BASE64"]
      app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: ENV["ASC_KEY_CONTENT_BASE64"],
        is_key_content_base64: true,
        in_house: false
      )
    # Option 2: Use key_filepath if you have the .p8 file
    elsif ENV["ASC_KEY_FILEPATH"]
      app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_filepath: ENV["ASC_KEY_FILEPATH"],
        in_house: false
      )
    # Option 3: Fall back to Apple ID authentication if API key doesn't work
    elsif ENV["FASTLANE_USER"] && ENV["FASTLANE_PASSWORD"]
      UI.important("Using Apple ID authentication instead of App Store Connect API key")
      # No explicit action needed, fastlane will use these environment variables
    # Option 4: Try with the regular key_content as a last resort
    else
      UI.important("Attempting with standard key_content - if this fails, try base64 encoding your key")
      app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: ENV["ASC_KEY_CONTENT"],
        in_house: false
      )
    end
    
    # Configure Xcode project for automatic signing
    update_code_signing_settings(
      use_automatic_signing: true,
      path: "ios/exporeactnativepaper.xcodeproj",
      team_id: ENV["APPLE_TEAM_ID"],
      targets: ["exporeactnativepaper"], # Update with your main target name
      build_configurations: ["Release", "Debug"]
    )
  end

  desc "Build iOS app for testing (for CI)"
  lane :build do
    setup_code_signing
    
    # Print debugging information
    UI.important("Xcode path: #{`xcode-select -p`.strip}")
    UI.important("Current directory: #{Dir.pwd}")
    
    # Use the project.xcworkspace inside the xcodeproj directory
    workspace_path = "ios/exporeactnativepaper.xcodeproj/project.xcworkspace"
    UI.important("Using workspace: #{workspace_path}")
    
    # Build the app with simplified configuration for CI
    build_ios_app(
      workspace: workspace_path,
      scheme: "exporeactnativepaper",
      export_method: "development", # Use development method for CI
      output_directory: ENV["FL_OUTPUT_DIR"] || "./build",
      output_name: "exporeactnativepaper-dev.ipa",
      xcargs: "COMPILER_INDEX_STORE_ENABLE=NO IPHONEOS_DEPLOYMENT_TARGET=14.0",
      include_symbols: false,
      include_bitcode: false,
      silent: false, # Show more build output
      skip_package_ipa: false, # This may help avoid archive errors
      skip_profile_detection: true, # Avoid extra profile detection steps
      export_options: {
        signingStyle: "automatic",
        teamID: ENV["APPLE_TEAM_ID"]
      }
    )
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    setup_code_signing
    
    # Print debugging information
    UI.important("Xcode path: #{`xcode-select -p`.strip}")
    UI.important("Current directory: #{Dir.pwd}")
    
    # Use the project.xcworkspace inside the xcodeproj directory
    workspace_path = "ios/exporeactnativepaper.xcodeproj/project.xcworkspace"
    UI.important("Using workspace: #{workspace_path}")
    
    # Increment build number
    increment_build_number(
      xcodeproj: "ios/exporeactnativepaper.xcodeproj"
    )
    
    # Build the app with simplified configuration
    build_ios_app(
      workspace: workspace_path,
      scheme: "exporeactnativepaper",
      export_method: "app-store",
      output_directory: ENV["FL_OUTPUT_DIR"] || "./build",
      output_name: "exporeactnativepaper.ipa",
      xcargs: "COMPILER_INDEX_STORE_ENABLE=NO IPHONEOS_DEPLOYMENT_TARGET=14.0", 
      clean: true,
      include_bitcode: false,
      silent: false, # Show more build output
      export_options: {
        signingStyle: "automatic",
        teamID: ENV["APPLE_TEAM_ID"],
        compileBitcode: false,
        provisioningProfiles: ENV["PROVISIONING_PROFILE_NAME"] ? 
          { (ENV["APP_IDENTIFIER"] || "com.yourcompany.exporeactnativepaper") => ENV["PROVISIONING_PROFILE_NAME"] } : nil
      }
    )
    
    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )
  end
  
  desc "Upload to TestFlight (for CircleCI)"
  lane :uploadtestflight do
    beta # Reuse the beta lane
  end

  desc "Take screenshots for iOS (requires UI tests)"
  lane :screenshots do
    capture_ios_screenshots(
      workspace: "ios/ExpoReactNativePaper.xcworkspace",
      scheme: "ExpoReactNativePaperUITests",
      devices: ["iPhone 8", "iPhone 11 Pro", "iPhone 13 Pro Max"],
      languages: ["en-US"],
      clear_previous_screenshots: true,
      output_directory: "fastlane/screenshots",
      skip_open_summary: true,
      override_status_bar: true,
      headless: true
    )
  end
end

platform :android do
  desc "Build Android app"
  lane :build do
    # Performance optimization - disable unused ABIs
    gradle_properties = {
      "android.abi.filter" => "armeabi-v7a,arm64-v8a",
      "android.enableR8.fullMode" => "true",
      "hermesEnabled" => "true"
    }
    
    # Build the app
    gradle(
      task: "assemble",
      build_type: "Release",
      project_dir: "android/",
      properties: {
        "android.injected.signing.store.file" => ENV["ANDROID_KEYSTORE_PATH"] || ENV["ANDROID_KEYSTORE_FILE"],
        "android.injected.signing.store.password" => ENV["ANDROID_KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["ANDROID_KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["ANDROID_KEY_PASSWORD"],
      }.merge(gradle_properties)
    )
  end

  desc "Build and upload to Play Store internal track"
  lane :beta do
    # Increment version code
    increment_version_code(
      gradle_file_path: "android/app/build.gradle"
    )
    
    # Performance optimization - disable unused ABIs
    gradle_properties = {
      "android.abi.filter" => "armeabi-v7a,arm64-v8a",
      "android.enableR8.fullMode" => "true",
      "hermesEnabled" => "true"
    }
    
    # Build Android App Bundle with performance optimizations
    gradle(
      task: "bundle",
      build_type: "Release",
      project_dir: "android/",
      properties: {
        "android.injected.signing.store.file" => ENV["ANDROID_KEYSTORE_PATH"] || ENV["ANDROID_KEYSTORE_FILE"],
        "android.injected.signing.store.password" => ENV["ANDROID_KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["ANDROID_KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["ANDROID_KEY_PASSWORD"],
      }.merge(gradle_properties)
    )
    
    # Upload to Play Store
    upload_to_play_store(
      track: 'internal',
      release_status: 'draft',
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      json_key: ENV["GOOGLE_PLAY_JSON_KEY"]
    )
  end
  
  desc "Build and deploy to Google Play Store"
  lane :deploy_to_production do
    # Print debug info for Android build
    UI.important("Starting Android production build")
    UI.important("Keystore path: #{ENV['ANDROID_KEYSTORE_PATH']}")
    UI.important("Key alias: #{ENV['ANDROID_KEY_ALIAS'] || 'not set'}")
    
    # Increment version code
    increment_version_code(
      gradle_file_path: "android/app/build.gradle"
    )
    
    # Build the Android app
    gradle(
      task: "clean assembleRelease",
      project_dir: "android/",
      properties: {
        "android.injected.signing.store.file" => ENV["ANDROID_KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["ANDROID_KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["ANDROID_KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["ANDROID_KEY_PASSWORD"]
      }
    )
    
    # Upload to Google Play
    upload_to_play_store(
      track: "production",
      release_status: "completed",
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      json_key_data: ENV["GOOGLE_PLAY_JSON_KEY"]
    )
  end
  
  desc "Build and deploy to Firebase App Distribution"
  lane :deploy_to_firebase do
    # Print debug info
    UI.important("Starting Android Firebase build")
    UI.important("Keystore path: #{ENV['ANDROID_KEYSTORE_PATH']}")
    
    # Build the Android app
    gradle(
      task: "clean assembleRelease",
      project_dir: "android/",
      properties: {
        "android.injected.signing.store.file" => ENV["ANDROID_KEYSTORE_PATH"],
        "android.injected.signing.store.password" => ENV["ANDROID_KEYSTORE_PASSWORD"],
        "android.injected.signing.key.alias" => ENV["ANDROID_KEY_ALIAS"],
        "android.injected.signing.key.password" => ENV["ANDROID_KEY_PASSWORD"]
      }
    )
    
    # Upload to Firebase
    firebase_app_distribution(
      app: ENV["FIREBASE_APP_ID_ANDROID"],
      groups: "testers",
      release_notes: "New test build",
      firebase_cli_token: ENV["FIREBASE_CLI_TOKEN"]
    )
  end

  desc "Take screenshots for Android (requires Espresso tests)"
  lane :screenshots do
    capture_android_screenshots(
      app_package_name: "com.yourname.exporeactnativepaper",
      app_apk_path: "android/app/build/outputs/apk/debug/app-debug.apk",
      tests_apk_path: "android/app/build/outputs/apk/androidTest/debug/app-debug-androidTest.apk",
      locales: ["en-US"],
      clear_previous_screenshots: true,
      test_instrumentation_runner: "androidx.test.runner.AndroidJUnitRunner",
      output_directory: "fastlane/metadata/android",
      skip_open_summary: true
    )
  end
end

desc "Generate screenshots for both iOS and Android (if UI tests exist)"
lane :screenshots do
  ios_screenshots
  android_screenshots
end